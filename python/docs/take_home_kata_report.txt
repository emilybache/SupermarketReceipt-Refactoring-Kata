1. Creating tests for covering all the features

- Created 25 Comprehensive Test Cases covering:

    - All 4 offer types (3-for-2, 2-for-amount, 5-for-amount, 10% discount)
    - Bundle offers (6 test cases for the new feature)
    - Edge cases and boundary conditions
    - Multiple products with different offers
    - Mixed scenarios (products with and without offers)
    - Basic cart operations

2. Identified and Fixed Code Smells:

    - Long Method: Reduced handle_offers() from 42 lines to 8 lines (81% reduction)
    - Feature Envy: Moved discount calculation logic into Offer classes
    - Duplicate Code: Eliminated repeated calculation patterns
    - Magic Numbers: Encapsulated in class names and logic
    - Switch Statements: Replaced type checking with polymorphism
    - Primitive Obsession: Improved with Pythonic idioms (dict.get(), generator expressions)

3. Applied Design Patterns:

    - Strategy Pattern: Polymorphic Offer classes (including BundleOffer)
    - Template Method: Abstract base class with concrete implementations
    - Factory Pattern: Teller creates appropriate offer instances
    - Tell, Don't Ask: Objects perform operations rather than exposing data

4. Refactored Code:
    - Created abstract Offer base class
    - Implemented 5 concrete offer classes: 
        * ThreeForTwoOffer
        * TwoForAmountOffer
        * FiveForAmountOffer
        * TenPercentDiscountOffer
        * BundleOffer (new feature)
    - Simplified ShoppingCart.handle_offers() to delegate to polymorphic offers
    - Applied Pythonic improvements (dict.get(), sum with generators)
    - Unified offer management with polymorphic add_offer() method

5. Added New Bundle Offer Feature:
    - Implemented BundleOffer class for discounting product bundles
    - When buying all items in a bundle, customer gets percentage off total
    - Only complete bundles are discounted
    - Works with multiple bundles (e.g., buy 2 sets, get 2 discounts)
    - Integrated seamlessly with existing offer system
    - 6 comprehensive test cases covering all bundle scenarios

6. Restructured Domain Folder Architecture:

    Final structure:
    domain/
    ├── __init__.py
    ├── entities/
    │   ├── __init__.py
    │   ├── product.py (Product, ProductUnit, ProductQuantity)
    │   ├── special_offer_type.py (SpecialOfferType enum)
    │   ├── discount.py (Discount)
    │   ├── receipt.py (Receipt, ReceiptItem)
    │   └── offers/
    │       ├── __init__.py
    │       ├── offer.py (Offer abstract base class)
    │       ├── three_for_two_offer.py (inherits from Offer)
    │       ├── two_for_amount_offer.py (inherits from Offer)
    │       ├── five_for_amount_offer.py (inherits from Offer)
    │       ├── ten_percent_discount_offer.py (inherits from Offer)
    │       └── bundle_offer.py (inherits from Offer)
    └── infrastructure/
        ├── __init__.py
        ├── catalog.py (SupermarketCatalog)
        ├── fake_catalog.py (FakeCatalog for testing)
        ├── teller.py (Teller)
        ├── shopping_cart.py (ShoppingCart)
        └── receipt_printer.py (ReceiptPrinter)

    Benefits:
    - Clear separation of concerns (entities vs infrastructure)
    - Domain entities isolated from infrastructure code
    - Offers grouped as a cohesive subdomain
    - Easy to navigate and maintain
    - Follows Domain-Driven Design principles
    - ALL offers inherit from Offer base class (true polymorphism)

7. Achieved True Polymorphism:

    ✅ Unified Offer Interface:
       - All offers (including BundleOffer) now inherit from Offer base class
       - Single calculate_discount(cart, catalog) method signature for all offers
       - No special case handling for different offer types
    
    ✅ Simplified ShoppingCart:
       - handle_offers() treats all offers uniformly (9 lines)
       - No isinstance checks or type discrimination
       - Simple loop: for each offer, calculate discount, apply if exists
    
    ✅ Simplified Teller:
       - Single offers list (not separate lists for different types)
       - Single add_offer() method works for ALL offer types
       - No special handling for bundle offers
    
    ✅ True Strategy Pattern Implementation:
       - Each offer is a complete strategy
       - Offers are interchangeable through common interface
       - Easy to add new offer types without modifying existing code

8. Code Examples - Before vs After:

    BEFORE (ShoppingCart.handle_offers - 42 lines with nested conditionals):
    ========================================================================
    def handle_offers(self, receipt, offers, catalog):
        for product in self.product_quantities.keys():
            quantity = self.product_quantities[product]
            if product in offers:
                offer = offers[product]
                unit_price = catalog.unit_price(product)
                quantity_as_int = quantity
                discount = None
                x = 1
                if offer.offer_type == SpecialOfferType.THREE_FOR_TWO:
                    x = 3
                elif offer.offer_type == SpecialOfferType.TWO_FOR_AMOUNT:
                    x = 2
                    if quantity_as_int >= 2:
                        total = offer.argument * (quantity_as_int // x) + ...
                        discount_n = unit_price * quantity - total
                        discount = Discount(product, "2 for " + str(offer.argument), discount_n)
                # ... 25+ more lines of nested if/elif statements ...

    AFTER (ShoppingCart.handle_offers - 9 lines, true polymorphism):
    =================================================================
    def handle_offers(self, receipt, offers, catalog):
        """Apply all offers to products in the cart.
        
        All offers are now treated uniformly through polymorphism.
        Each offer knows how to calculate its own discount based on cart contents.
        """
        for offer in offers:
            discount = offer.calculate_discount(self, catalog)
            if discount:
                receipt.add_discount(discount)

    -------------------------------------------------------------------------

    BEFORE (Teller - separate handling for different offer types):
    ================================================================
    class Teller:
        def __init__(self, catalog):
            self.catalog = catalog
            self.offers = {}            # Dictionary for regular offers
            self.bundle_offers = []     # Separate list for bundle offers

        def add_offer(self, offer):
            """Add offer with type checking"""
            if isinstance(offer, BundleOffer):
                self.bundle_offers.append(offer)  # Special case!
            else:
                self.offers[offer.product] = offer

        def checks_out_articles_from(self, cart):
            # ... create receipt ...
            cart.handle_offers(receipt, self.offers, self.bundle_offers, catalog)
            #                           ^^^^^^^^^^^  ^^^^^^^^^^^^^
            #                           Two separate parameters!

    AFTER (Teller - uniform handling of all offers):
    ================================================
    class Teller:
        def __init__(self, catalog):
            self.catalog = catalog
            self.offers = []  # Single list for ALL offers

        def add_offer(self, offer):
            """Add any offer polymorphically - works for ALL offer types"""
            self.offers.append(offer)  # No type checking needed!

        def checks_out_articles_from(self, cart):
            # ... create receipt ...
            cart.handle_offers(receipt, self.offers, catalog)
            #                           ^^^^^^^^^^^
            #                           Single list!

    -------------------------------------------------------------------------

    BEFORE (BundleOffer - separate class, different interface):
    ===========================================================
    class BundleOffer:  # Does not inherit from Offer!
        def __init__(self, products, discount_percentage):
            self.products = products
            self.discount_percentage = discount_percentage
        
        def calculate_discount(self, product_quantities, catalog):
            # Different signature than other offers!
            # ...

    AFTER (BundleOffer - inherits from Offer, unified interface):
    =============================================================
    class BundleOffer(Offer):  # Inherits from Offer!
        def __init__(self, products, discount_percentage):
            self.products = products
            self.discount_percentage = discount_percentage
        
        def applies_to_product(self, product):
            return product in self.products
        
        def calculate_discount(self, cart, catalog):
            # Same signature as all other offers!
            # ...

9. Key Achievements:

    ✅ No Type Checking: Zero isinstance() checks - true polymorphism
    ✅ Single Responsibility: Each offer class has one clear purpose
    ✅ Open/Closed: Added BundleOffer without modifying existing offers
    ✅ Unified Interface: All offers use calculate_discount(cart, catalog)
    ✅ Simplified Logic: 81% complexity reduction in handle_offers()
    ✅ Clean Architecture: Clear domain/infrastructure separation

10. SOLID Principles Applied:

    ✅ Single Responsibility Principle:
       - Each offer class has ONE job: calculate its specific discount
       - ShoppingCart manages cart contents, not discount logic
       - Teller orchestrates checkout, delegates discounts to offers
       - Clear separation between entities and infrastructure
    
    ✅ Open/Closed Principle:
       - Added BundleOffer without modifying ANY existing offer classes
       - Can add new offer types by creating new classes, not editing old ones
       - ShoppingCart and Teller don't need changes for new offers
    
    ✅ Liskov Substitution Principle:
       - ANY Offer subclass can replace the base Offer class
       - BundleOffer works identically to other offers from client perspective
       - No special case handling needed
    
    ✅ Interface Segregation Principle:
       - Clean, focused interface (calculate_discount, applies_to_product)
       - Offers only implement what they need